
2048 notes / voice

128 notes / OSC message

append notes to a voice's loop
	whether or not it is playing
	
Want voice1 to be drums? Okie-dokie.
	Drums are detected via pitch
	Drum messages are sent in packages of 7 notes and 1/16th slots, all at once to the PD patch.
	
1/8 of a beat (== 1/32 note resolution) => now;
index in MASTER LOOP += 1
any notes information relevant to now?
	check this slot in the MASTER LOOP across all 8 voices
		iterate down each voice in the MASTER LOOP
			for each NOTE found
				if NOTE is melodic
					add NOTE data (pitch + duration) to NOTE_PACKAGE
				if NOTE is a drum pitch
					add drum pitch to DRUM_PACKAGE
if NOTE_PACKAGE contains anything
	send Pd 8-command OSC message reflecting the NOTE_PACKAGE
if DRUM_PACKAGE contains anything
	send Pd 7-command OSC message reflecting the DRUM_PACKAGE
	
the MASTER LOOP.

The master loop is an array where each slot represents a 1/8th of a beat.
The master loop is multi-dimensional:
	1st dimension (size 8): voice-specify
	2nd dimension (size MASTER_LOOP_LENGTH_IN_BEATS*8): fractional-beat-specify
	3rd dimension (size 2): pitch, then duration (notes)
The master loop is initialized in the beginning of the program
The master loop is modified by OSC phrase commands

// processing play voice messages
set index = master loop index + beat alignment
set notes_added_index = 0
for each note in the phrase data
	add the note to the master loop
	add index to notes_added[voice][notes_added_index]
	increment index by the duration processed
	index %= master loop beat size
	if should_exit(this voice)
		

10 // start note, end note
1_ // start note
0_ // end note
01 // end (last) note, start (new) note

voice1[n ][  ][  ][  ][en][  ][  ][e ]
voice2[  ][  ][n ][  ][  ][en][  ][e ]
voice3[ne][  ][  ][  ][ne][  ][  ][  ] // (being used as drums)
voice4[  ][  ][  ][  ][  ][  ][  ][  ]
voice5[  ][  ][  ][  ][  ][  ][  ][  ]
voice6[  ][  ][  ][  ][  ][  ][  ][  ]
voice7[  ][  ][  ][  ][  ][  ][  ][  ]
voice8[  ][  ][  ][  ][  ][  ][  ][  ]

// OLD CODE FOR DOING PROCESSING OVER TIMESLOTS INSTEAD OF ALL AT ONCE

function void play_voice_message_processor(
        int phrase_data[], int voice,
        int should_loop_flag, int append_flag,
        float beat_delay, float beat_alignment) {	
	// Iterate through phrase data.
    // Never copy more data than needed
    // at any given time, allowing time to pass
    // between bouts of copying notes to the
    // master loop to allow other shreds a
    // change to do the same.
    // First, set starting index for placing
    // notes into the master loop.
    0 => int start_index;
    if (append_flag) {
        voice_end_indices[voice] => start_index;
        beat_align(
                voice_end_indices[voice],
                beat_alignment)
                         => start_index;
    }
    else {
        // TODO: Since there was no append flag
        // we PROBABLY need to RESET this voice's notes!!
        // Just align based on the next upcoming
        // master loop index
        beat_align(master_loop_index+1, beat_alignment)
                         => start_index;
    }
    // Place at least BEAT_RESOLUTION_DIVIDER timeslots
    // worth of notes into the master loop (8 by default).
    0 => int duration_processed;
    0 => int timeslots_allowed_to_pass_since_start;
    for (0 => int i; i < 128; i++) {
        phrase_data[i] => int pitch;
        i++;
        phrase_data[i] => int duration;
        // Add note to master loop, store number of timeslots
        // that note was worth in duration_processed.
        add_note_to_master_loop(
                start_index + duration_processed,
                pitch, duration, voice)
                         +=> duration_processed;
        if (duration_processed
                - time_allowed_to_pass_since_start
                >= BEAT_RESOLUTION_DIVIDER) {
            // Processed at least a beat (B_R_D timeslots).
            // Set new voice end index for this voice.
            start_index + duration_processed
                         => voice_end_indices[voice];
            // Finally, allow time processed thus far to pass so
            // other shreds can have a go at the master loop.
            // Time to wait is duration processed unless
            // this is our first time getting here, in which case
            // it's half that duration, to give us a little
            // bit of leeway.
            beat_fraction_to_seconds(
                    duration_processed
                    - timeslots_allowed_to_pass_since_start)
                    ::second
                         => now;
            duration_processed
                         +=> timeslots_allowed_to_pass_since_start;
        }
        if (should_loop_flag && i == 128) {
            // Allow looping.
            // (i will get incremented to 0 at the top
            // of the loop.)
            -1 => i;
        }
    }
}