
2048 notes / voice

128 notes / OSC message

append notes to a voice's loop
	whether or not it is playing
	
Want voice1 to be drums? Okie-dokie.
	Drums are detected via pitch
	Drum messages are sent in packages of 7 notes and 1/16th slots, all at once to the PD patch.
	
1/8 of a beat (== 1/32 note resolution) => now;
index in MASTER LOOP += 1
any notes information relevant to now?
	check this slot in the MASTER LOOP across all 8 voices
		iterate down each voice in the MASTER LOOP
			for each NOTE found
				if NOTE is melodic
					add NOTE data (pitch + duration) to NOTE_PACKAGE
				if NOTE is a drum pitch
					add drum pitch to DRUM_PACKAGE
if NOTE_PACKAGE contains anything
	send Pd 8-command OSC message reflecting the NOTE_PACKAGE
if DRUM_PACKAGE contains anything
	send Pd 7-command OSC message reflecting the DRUM_PACKAGE
	
the MASTER LOOP.

The master loop is an array where each slot represents a 1/8th of a beat.
The master loop is multi-dimensional:
	1st dimension (size 8): voice-specify
	2nd dimension (size MASTER_LOOP_LENGTH_IN_BEATS*8): fractional-beat-specify
	3rd dimension (size 2): pitch, then duration (notes)
The master loop is initialized in the beginning of the program
The master loop is modified by OSC phrase commands

// processing play voice messages
init globally:
	notes_added[NUM_VOICES][2048]
	notes_added_start[NUM_VOICES]

on master_loop consumes a voice note:
	remove_note(that note from that voice)
	increment notes_added_start[that voice] by 1
	notes_added_start[that voice] %= 2048 you know
	
on stop_event[voice]:
	set should_exit(voice)
	do_exit(voice)

on process play voice message:
	set index = master loop index + beat alignment
	set notes_added_start_index[voice] = 0
	set notes_added_index = 0
	for each note in the phrase data
		add the note to the master loop
		add index to notes_added[voice][notes_added_index]
		increment index by the duration processed
		increment notes_added_index by 1
		index %= master loop beat size
		notes_added_index %= master loop beat size
		if should_exit(this voice)
			break!
		if looping && last note added:
			wait total_duration_processed
			if should_exit(this voice)
				break!
			reset note index
	
		
do_exit(voice):
	for (note in notes_added[voice]), starting at notes_added_start[voice]:
		if note is already empty:
			break!
		remove_note(that note from that voice)

10 // start note, end note
1_ // start note
0_ // end note
01 // end (last) note, start (new) note

voice1[n ][  ][  ][  ][en][  ][  ][e ]
voice2[  ][  ][n ][  ][  ][en][  ][e ]
voice3[ne][  ][  ][  ][ne][  ][  ][  ] // (being used as drums)
voice4[  ][  ][  ][  ][  ][  ][  ][  ]
voice5[  ][  ][  ][  ][  ][  ][  ][  ]
voice6[  ][  ][  ][  ][  ][  ][  ][  ]
voice7[  ][  ][  ][  ][  ][  ][  ][  ]
voice8[  ][  ][  ][  ][  ][  ][  ][  ]

// OLD CODE FOR DOING PROCESSING OVER TIMESLOTS INSTEAD OF ALL AT ONCE

function void play_voice_message_processor(
        int phrase_data[], int voice,
        int should_loop_flag, int append_flag,
        float beat_delay, float beat_alignment) {	
	// Iterate through phrase data.
    // Never copy more data than needed
    // at any given time, allowing time to pass
    // between bouts of copying notes to the
    // master loop to allow other shreds a
    // change to do the same.
    // First, set starting index for placing
    // notes into the master loop.
    0 => int start_index;
    if (append_flag) {
        voice_end_indices[voice] => start_index;
        beat_align(
                voice_end_indices[voice],
                beat_alignment)
                         => start_index;
    }
    else {
        // TODO: Since there was no append flag
        // we PROBABLY need to RESET this voice's notes!!
        // Just align based on the next upcoming
        // master loop index
        beat_align(master_loop_index+1, beat_alignment)
                         => start_index;
    }
    // Place at least BEAT_RESOLUTION_DIVIDER timeslots
    // worth of notes into the master loop (8 by default).
    0 => int duration_processed;
    0 => int timeslots_allowed_to_pass_since_start;
    for (0 => int i; i < 128; i++) {
        phrase_data[i] => int pitch;
        i++;
        phrase_data[i] => int duration;
        // Add note to master loop, store number of timeslots
        // that note was worth in duration_processed.
        add_note_to_master_loop(
                start_index + duration_processed,
                pitch, duration, voice)
                         +=> duration_processed;
        if (duration_processed
                - time_allowed_to_pass_since_start
                >= BEAT_RESOLUTION_DIVIDER) {
            // Processed at least a beat (B_R_D timeslots).
            // Set new voice end index for this voice.
            start_index + duration_processed
                         => voice_end_indices[voice];
            // Finally, allow time processed thus far to pass so
            // other shreds can have a go at the master loop.
            // Time to wait is duration processed unless
            // this is our first time getting here, in which case
            // it's half that duration, to give us a little
            // bit of leeway.
            beat_fraction_to_seconds(
                    duration_processed
                    - timeslots_allowed_to_pass_since_start)
                    ::second
                         => now;
            duration_processed
                         +=> timeslots_allowed_to_pass_since_start;
        }
        if (should_loop_flag && i == 128) {
            // Allow looping.
            // (i will get incremented to 0 at the top
            // of the loop.)
            -1 => i;
        }
    }
}

// =================================
// =================================
// NOTE PLAYING TESTING RAW
// =================================
// =================================

/*// DEBUG put debug stuff into the master loop
// for testing purposes
for (0 => int i; i < 16*8; 8 +=> i) {
    // bass drum every beat
    -10 => master_loop[16][i][0];
    0 => master_loop[16][i][1];
    // snare drum
    -11 => master_loop[17][i+4][0];
    0 => master_loop[17][i+4][1];
    -11 => master_loop[17][i+6][0];
    0 => master_loop[17][i+6][1];
    // conga drum
    -12 => master_loop[18][i][0];
    0 => master_loop[18][i][1];
    // tom drum
    -13 => master_loop[19][i][0];
    0 => master_loop[19][i][1];
    // hat drum
    -14 => master_loop[20][i][0];
    0 => master_loop[20][i][1];
    // hit drum
    -15 => master_loop[21][i][0];
    0 => master_loop[21][i][1];
    // ride drum
    -16 => master_loop[22][i][0];
    0 => master_loop[22][i][1];
}
// some voice 1 notes
add_note(4, 25, 1, 0);
add_note(5, 29, 1, 0);
add_note(6, 32, 1, 0);
add_note(7, 29, 1, 0);
add_note(8, 30, 1, 0);
// some voice 2 notes
add_note(4, 29, 1, 1);
add_note(5, 32, 1, 1);
add_note(6, 36, 1, 1);
add_note(7, 32, 1, 1);
add_note(8, 34, 1, 1);
// some voice 3 notes
add_note(4, 32, 1, 2);
add_note(5, 37, 1, 2);
add_note(6, 41, 1, 2);
add_note(7, 37, 1, 2);
add_note(8, 39, 1, 2);
// some voice 4 notes
add_note(4, 37, 1, 3);
add_note(5, 41, 1, 3);
add_note(6, 44, 1, 3);
add_note(7, 41, 1, 3);
add_note(8, 42, 1, 3);
// some voice 5 notes
add_note(4, 41, 1, 4);
add_note(5, 44, 1, 4);
add_note(6, 48, 1, 4);
add_note(7, 44, 1, 4);
add_note(8, 46, 1, 4);
// some voice 6 notes
add_note(4, 44, 1, 5);
add_note(5, 49, 1, 5);
add_note(6, 53, 1, 5);
add_note(7, 49, 1, 5);
add_note(8, 51, 1, 5);
// some voice 7 notes
add_note(4, 20, 0.5, 6);
add_note(4.5, 17, 0.5, 6);
add_note(5, 20, 0.5, 6);
add_note(5.5, 17, 0.5, 6);
add_note(6, 20, 0.5, 6);
add_note(6.5, 17, 0.5, 6);
add_note(7, 20, 0.5, 6);
add_note(7.5, 17, 0.5, 6);
add_note(8, 15, 1, 6);
// some voice 8 notes
add_note(4, 25, 0.5, 7);
add_note(4.5, 20, 0.5, 7);
add_note(5, 25, 0.5, 7);
add_note(5.5, 20, 0.5, 7);
add_note(6, 25, 0.5, 7);
add_note(6.5, 20, 0.5, 7);
add_note(7, 25, 0.5, 7);
add_note(7.5, 20, 0.5, 7);
add_note(8, 18, 1, 7);

function void add_note(float beat,
                       int pitch,
                       float duration_in_beats,
                       int voice) {
    pitch + 35 => master_loop[voice][((beat*8) $ int)][0];
    (duration_in_beats * BEAT_RESOLUTION_DIVIDER) $ int =>
                    master_loop[voice][((beat*8) $ int)][1];
}*/